commit 511431ce6bf6a72b0f685c6c9fe73d359a5713c0
Author: GodGotzi <eli.gottsbacher@gmail.com>
Date:   Mon May 8 22:39:10 2023 +0200

    setup

diff --git a/src/fiberslice.rs b/src/fiberslice.rs
new file mode 100644
index 0000000..6fbba60
--- /dev/null
+++ b/src/fiberslice.rs
@@ -0,0 +1,26 @@
+pub mod utils;
+pub mod window;
+
+pub mod wgpu {
+    use wgpu::{Adapter, Device, Instance, Queue, RequestDeviceError, Surface};
+
+    pub(crate) fn request_wgpu_adapter(instance: &Instance, surface: &Surface) -> Option<Adapter> {
+        pollster::block_on(instance.request_adapter(&wgpu::RequestAdapterOptions {
+            power_preference: wgpu::PowerPreference::HighPerformance,
+            compatible_surface: Some(&surface),
+            force_fallback_adapter: false,
+        }))
+    }
+
+    pub(crate) fn request_wgpu_device(adapter: &Adapter) -> Result<(Device, Queue), RequestDeviceError> {
+        pollster::block_on(adapter.request_device(
+            &wgpu::DeviceDescriptor {
+                features: wgpu::Features::default(),
+                limits: wgpu::Limits::default(),
+                label: None,
+            },
+            None,
+        ))
+    }
+
+}
\ No newline at end of file
diff --git a/src/fiberslice/utils.rs b/src/fiberslice/utils.rs
new file mode 100644
index 0000000..ed020ce
--- /dev/null
+++ b/src/fiberslice/utils.rs
@@ -0,0 +1,3 @@
+pub trait Creation {
+    fn create() -> Self;
+}
\ No newline at end of file
diff --git a/src/fiberslice/window.rs b/src/fiberslice/window.rs
new file mode 100644
index 0000000..308d106
--- /dev/null
+++ b/src/fiberslice/window.rs
@@ -0,0 +1,73 @@
+use wgpu::{Device, Surface, SurfaceConfiguration};
+use winit::event::WindowEvent;
+use winit::event_loop::ControlFlow;
+use winit::window::Window;
+
+pub struct WindowEventObserver<'a> {
+    window: &'a Window,
+}
+
+pub struct FiberSliceWindow<'a> {
+    window: &'a Window,
+    device: &'a Device,
+    surface: &'a Surface,
+    surface_config: &'a mut SurfaceConfiguration,
+}
+
+impl <'a> WindowEventObserver<'a> {
+
+    pub fn new(window: &'a Window) -> Self {
+        WindowEventObserver {
+            window
+        }
+    }
+
+    pub fn call_event(&self, event: WindowEvent, fiber_slice_window: &mut FiberSliceWindow, control_flow: &mut ControlFlow) {
+        match event {
+            WindowEvent::Resized(size) => {
+                // Resize with 0 width and height is used by winit to signal a minimize event on Windows.
+                // See: https://github.com/rust-windowing/winit/issues/208
+                // This solves an issue where the app would panic when minimizing on Windows.
+                if size.width > 0 && size.height > 0 {
+                    fiber_slice_window.surface_config.width = size.width;
+                    fiber_slice_window.surface_config.height = size.height;
+                    fiber_slice_window.surface.configure(fiber_slice_window.device, fiber_slice_window.surface_config);
+                }
+            }
+            WindowEvent::CloseRequested => {
+                *control_flow = ControlFlow::Exit;
+            }
+            _ => {
+
+            }
+        }
+    }
+}
+
+impl <'a> FiberSliceWindow<'a> {
+
+    pub fn new(window: &'a Window, device: &'a Device, surface: &'a Surface, surface_config: &'a mut SurfaceConfiguration) -> Self {
+        FiberSliceWindow {
+            window,
+            device,
+            surface,
+            surface_config,
+        }
+    }
+
+    pub fn get_window(&self) -> &Window {
+        self.window
+    }
+
+    pub fn get_surface(&self) -> &Surface {
+        self.surface
+    }
+
+    pub fn get_surface_config(&self) -> &SurfaceConfiguration {
+        self.surface_config
+    }
+
+    pub fn get_device(&self) -> &Device {
+        self.device
+    }
+}
\ No newline at end of file
diff --git a/src/main.rs b/src/main.rs
index b351c8e..6c638ab 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,64 +1,33 @@
+mod window_builder;
+mod fiberslice;
+
 use std::iter;
 use std::time::Instant;
 
-use ::egui::FontDefinitions;
-use chrono::Timelike;
+use egui::FontDefinitions;
 use egui_wgpu_backend::{RenderPass, ScreenDescriptor};
 use egui_winit_platform::{Platform, PlatformDescriptor};
 use winit::event::Event::*;
-use winit::event_loop::ControlFlow;
-const INITIAL_WIDTH: u32 = 1920;
-const INITIAL_HEIGHT: u32 = 1080;
-
-/// A custom event type for the winit app.
-enum Event {
-    RequestRedraw,
-}
-
-/// This is the repaint signal type that egui needs for requesting a repaint from another thread.
-/// It sends the custom RequestRedraw event to the winit event loop.
-struct ExampleRepaintSignal(std::sync::Mutex<winit::event_loop::EventLoopProxy<Event>>);
-
-impl epi::backend::RepaintSignal for ExampleRepaintSignal {
-    fn request_repaint(&self) {
-        self.0.lock().unwrap().send_event(Event::RequestRedraw).ok();
-    }
-}
-
-/// A simple egui + wgpu + winit based example.
+use winit::event_loop::{ControlFlow, EventLoop};
+use winit::window::Window;
+
+use window_builder::{create_winit_window, Event};
+use fiberslice::wgpu::request_wgpu_adapter;
+use fiberslice::utils::Creation;
+use fiberslice::wgpu::request_wgpu_device;
+use fiberslice::window::WindowEventObserver;
+use fiberslice::window::FiberSliceWindow;
+
 fn main() {
-    let event_loop = winit::event_loop::EventLoopBuilder::<Event>::with_user_event().build();
-    let window = winit::window::WindowBuilder::new()
-        .with_decorations(true)
-        .with_resizable(true)
-        .with_transparent(false)
-        .with_title("FiberSlice 5D")
-        .with_inner_size(winit::dpi::PhysicalSize {
-            width: INITIAL_WIDTH,
-            height: INITIAL_HEIGHT,
-        })
-        .build(&event_loop)
-        .unwrap();
+    let event_loop = EventLoop::create();
+    let window: Window = create_winit_window(&event_loop);
 
     let instance = wgpu::Instance::new(wgpu::Backends::PRIMARY);
     let surface = unsafe { instance.create_surface(&window) };
 
-    let adapter = pollster::block_on(instance.request_adapter(&wgpu::RequestAdapterOptions {
-        power_preference: wgpu::PowerPreference::HighPerformance,
-        compatible_surface: Some(&surface),
-        force_fallback_adapter: false,
-    }))
-    .unwrap();
-
-    let (device, queue) = pollster::block_on(adapter.request_device(
-        &wgpu::DeviceDescriptor {
-            features: wgpu::Features::default(),
-            limits: wgpu::Limits::default(),
-            label: None,
-        },
-        None,
-    ))
-    .unwrap();
+    let adapter = request_wgpu_adapter(&instance, &surface).unwrap();
+
+    let (device, queue) = request_wgpu_device(&adapter).unwrap();
 
     let size = window.inner_size();
     let surface_format = surface.get_supported_formats(&adapter)[0];
@@ -71,7 +40,6 @@ fn main() {
     };
     surface.configure(&device, &surface_config);
 
-    // We use the egui_winit_platform crate as the platform.
     let mut platform = Platform::new(PlatformDescriptor {
         physical_width: size.width as u32,
         physical_height: size.height as u32,
@@ -80,14 +48,17 @@ fn main() {
         style: Default::default(),
     });
 
-    // We use the egui_wgpu_backend crate as the render backend.
     let mut egui_rpass = RenderPass::new(&device, surface_format, 1);
 
+    let mut demo_app = egui_demo_lib::DemoWindows::default();
     let start_time = Instant::now();
+
     event_loop.run(move |event, _, control_flow| {
-        // Pass the winit events to the platform integration.
         platform.handle_event(&event);
 
+        let mut fiberslice_window = FiberSliceWindow::new(&window, &device, &surface, &mut surface_config);
+        let window_event_observer = WindowEventObserver::new(&window);
+
         match event {
             RedrawRequested(..) => {
                 platform.update_time(start_time.elapsed().as_secs_f64());
@@ -95,9 +66,6 @@ fn main() {
                 let output_frame = match surface.get_current_texture() {
                     Ok(frame) => frame,
                     Err(wgpu::SurfaceError::Outdated) => {
-                        // This error occurs when the app is minimized on Windows.
-                        // Silently return here to prevent spamming the console with:
-                        // "The underlying surface has changed, and therefore the swap chain must be updated"
                         return;
                     }
                     Err(e) => {
@@ -109,12 +77,10 @@ fn main() {
                     .texture
                     .create_view(&wgpu::TextureViewDescriptor::default());
 
-                // Begin to draw the UI frame.
                 platform.begin_frame();
 
-                // Draw the demo application.
+                demo_app.ui(&platform.context());
 
-                // End the UI frame. We could now handle the output and draw the UI with the backend.
                 let full_output = platform.end_frame(Some(&window));
                 let paint_jobs = platform.context().tessellate(full_output.shapes);
 
@@ -122,10 +88,9 @@ fn main() {
                     label: Some("encoder"),
                 });
 
-                // Upload all resources for the GPU.
                 let screen_descriptor = ScreenDescriptor {
-                    physical_width: surface_config.width,
-                    physical_height: surface_config.height,
+                    physical_width: fiberslice_window.get_surface_config().width,
+                    physical_height: fiberslice_window.get_surface_config().height,
                     scale_factor: window.scale_factor() as f32,
                 };
                 let tdelta: egui::TexturesDelta = full_output.textures_delta;
@@ -134,7 +99,6 @@ fn main() {
                     .expect("add texture ok");
                 egui_rpass.update_buffers(&device, &queue, &paint_jobs, &screen_descriptor);
 
-                // Record all render passes.
                 egui_rpass
                     .execute(
                         &mut encoder,
@@ -144,49 +108,22 @@ fn main() {
                         Some(wgpu::Color::BLACK),
                     )
                     .unwrap();
-                // Submit the commands.
+
                 queue.submit(iter::once(encoder.finish()));
 
-                // Redraw egui
                 output_frame.present();
 
                 egui_rpass
                     .remove_textures(tdelta)
                     .expect("remove texture ok");
-
-                // Support reactive on windows only, but not on linux.
-                // if _output.needs_repaint {
-                //     *control_flow = ControlFlow::Poll;
-                // } else {
-                //     *control_flow = ControlFlow::Wait;
-                // }
             }
             MainEventsCleared | UserEvent(Event::RequestRedraw) => {
                 window.request_redraw();
             }
-            WindowEvent { event, .. } => match event {
-                winit::event::WindowEvent::Resized(size) => {
-                    // Resize with 0 width and height is used by winit to signal a minimize event on Windows.
-                    // See: https://github.com/rust-windowing/winit/issues/208
-                    // This solves an issue where the app would panic when minimizing on Windows.
-                    if size.width > 0 && size.height > 0 {
-                        surface_config.width = size.width;
-                        surface_config.height = size.height;
-                        surface.configure(&device, &surface_config);
-                    }
-                }
-                winit::event::WindowEvent::CloseRequested => {
-                    *control_flow = ControlFlow::Exit;
-                }
-                _ => {}
+            WindowEvent { event, .. } => {
+                window_event_observer.call_event(event, &mut fiberslice_window, control_flow);
             },
             _ => (),
         }
     });
-}
-
-/// Time of day as seconds since midnight. Used for clock in demo app.
-pub fn seconds_since_midnight() -> f64 {
-    let time = chrono::Local::now().time();
-    time.num_seconds_from_midnight() as f64 + 1e-9 * (time.nanosecond() as f64)
 }
\ No newline at end of file
diff --git a/src/window_builder.rs b/src/window_builder.rs
new file mode 100644
index 0000000..d6b1a71
--- /dev/null
+++ b/src/window_builder.rs
@@ -0,0 +1,38 @@
+use winit::event_loop::EventLoop;
+use winit::window::Window;
+use crate::fiberslice::utils::Creation;
+
+const INITIAL_WIDTH: u32 = 1920;
+const INITIAL_HEIGHT: u32 = 1080;
+
+pub enum Event {
+    RequestRedraw,
+}
+
+pub struct DefaultRepaintSignal(std::sync::Mutex<winit::event_loop::EventLoopProxy<Event>>);
+
+impl epi::backend::RepaintSignal for DefaultRepaintSignal {
+    fn request_repaint(&self) {
+        self.0.lock().unwrap().send_event(Event::RequestRedraw).ok();
+    }
+}
+
+pub fn create_winit_window(event_loop: &EventLoop<Event>) -> Window {
+    winit::window::WindowBuilder::new()
+        .with_decorations(true)
+        .with_resizable(true)
+        .with_transparent(false)
+        .with_title("FiberSlice 5D")
+        .with_inner_size(winit::dpi::PhysicalSize {
+            width: INITIAL_WIDTH,
+            height: INITIAL_HEIGHT,
+        })
+        .build(&event_loop)
+        .unwrap()
+}
+
+impl Creation for EventLoop<Event> {
+    fn create() -> Self {
+        winit::event_loop::EventLoopBuilder::<Event>::with_user_event().build()
+    }
+}
\ No newline at end of file

