commit 23ccb06afc450e564bf64fc876508c0d483d4667
Author: GodGotzi <eli.gottsbacher@gmail.com>
Date:   Wed May 31 23:25:08 2023 +0200

    bevy query resource change

diff --git a/src/component.rs b/src/component.rs
index 9783b27..8b13789 100644
--- a/src/component.rs
+++ b/src/component.rs
@@ -1,41 +1 @@
-use std::fmt::Display;
 
-use bevy::{window::Window, prelude::Query};
-use bevy_egui::{EguiContexts, egui::{Order, LayerId, Id}};
-
-pub struct EguiData {
-    touch: bool    
-}
-
-impl EguiData {
-
-    pub fn new() -> Self {
-        Self {
-            touch: false
-        }
-    }
-
-    pub fn is_touch(&self) -> bool {
-        self.touch
-    }
-
-    pub fn check_touch(
-        &mut self, 
-        mut contexts: EguiContexts, 
-        mut windows: Query<&mut Window>
-    ) {
-        let ctx = contexts.ctx_mut();
-
-        let pointer_pos = ctx.input(|i| i.pointer.interact_pos());
-        if let Some(pointer_pos) = pointer_pos {
-            if let Some(layer) = ctx.layer_id_at(pointer_pos) {
-                println!("{}", layer.order.short_debug_format());
-            } else {
-                self.touch = false
-            }
-        } else {
-            self.touch = false
-        }
-    }
-
-}
\ No newline at end of file
diff --git a/src/fiberslice.rs b/src/fiberslice.rs
index 5281b98..a19f938 100644
--- a/src/fiberslice.rs
+++ b/src/fiberslice.rs
@@ -1,3 +1,71 @@
+use bevy::prelude::{Resource, ResMut};
+
+use crate::view::{ViewInterface, self};
+
+use self::screen::Screen;
+
 pub mod utils;
 pub mod screen;
-mod options;
\ No newline at end of file
+mod options;
+
+#[derive(Resource)]
+pub struct FiberSlice {
+    screen: Screen,
+}
+
+impl FiberSlice {
+
+    pub fn new() -> Self {
+        Self {
+            screen: Screen::new(),
+        }
+    }
+
+    pub fn ui_frame(&mut self, ctx: &bevy_egui::egui::Context, view_interface: &mut ResMut<ViewInterface>) {
+        self.screen.ui(ctx, view_interface);
+    }
+
+}
+
+
+pub mod gui {
+    use bevy::{prelude::{Resource, ResMut}};
+    use bevy_egui::EguiContexts;
+
+    
+    #[derive(Resource)]
+    pub struct GuiInterface {
+        touch: bool    
+    }
+
+    impl GuiInterface {
+
+        pub fn new() -> Self {
+            Self {
+                touch: false
+            }
+        }
+
+        pub fn _is_touch(&self) -> bool {
+            self.touch
+        }
+    }
+    
+    pub fn check_touch(
+        mut contexts: EguiContexts, 
+        mut gui_interface: ResMut<GuiInterface>
+    ) {
+        let ctx = contexts.ctx_mut();
+
+        let pointer_pos = ctx.input(|i| i.pointer.interact_pos());
+        if let Some(pointer_pos) = pointer_pos {
+            if let Some(layer) = ctx.layer_id_at(pointer_pos) {
+                println!("{}", layer.order.short_debug_format());
+            } else {
+                gui_interface.touch = false;
+            }
+        } else {
+            gui_interface.touch = false;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/fiberslice/screen.rs b/src/fiberslice/screen.rs
index 055597e..9b59b99 100644
--- a/src/fiberslice/screen.rs
+++ b/src/fiberslice/screen.rs
@@ -1,7 +1,8 @@
 mod side;
 
+use bevy::prelude::ResMut;
 use bevy_egui::egui::{self, LayerId, Id};
-use crate::fiberslice::screen::menu::menubar_ui;
+use crate::{fiberslice::screen::menu::menubar_ui, view::ViewInterface};
 
 mod menu {
     use bevy_egui::egui::{self, LayerId, Id};
@@ -91,8 +92,8 @@ impl Screen {
         }
     }
 
-    pub(crate) fn ui(&mut self, ctx: &egui::Context) {
+    pub(crate) fn ui(&mut self, ctx: &egui::Context, view_interface: &mut ResMut<ViewInterface>) {
         menubar_ui(ctx, self);
-        self.side_view_data.side_panel_ui(ctx);
+        self.side_view_data.side_panel_ui(ctx, view_interface);
     }
 }
\ No newline at end of file
diff --git a/src/fiberslice/screen/side.rs b/src/fiberslice/screen/side.rs
index d0cb08e..5d69f2d 100644
--- a/src/fiberslice/screen/side.rs
+++ b/src/fiberslice/screen/side.rs
@@ -1,8 +1,11 @@
+use bevy::prelude::ResMut;
 use bevy_egui::egui;
 use egui::{Context, Direction, Ui};
 use egui_extras::Size;
 use egui_grid::GridBuilder;
 
+use crate::view::ViewInterface;
+
 #[derive(PartialEq)]
 pub enum OptionPanel {
     SliceSettings,
@@ -19,7 +22,7 @@ impl TabbedView {
         }
     }
 
-    pub fn show(&mut self, ctx: &Context, ui: &mut Ui, side_view: &mut SideView) {
+    pub fn show(&mut self, ctx: &Context, ui: &mut Ui, side_view: &mut SideView, view_interface: &mut ResMut<ViewInterface>) {
         ui.horizontal(|ui| {
             let layout = egui::Layout {
                 main_dir: Direction::TopDown,
@@ -95,6 +98,11 @@ impl TabbedView {
         match side_view.open_panel {
             OptionPanel::SliceSettings => {
                 ui.label("a");
+
+                if ui.button("test").clicked() {
+                    view_interface.change_view_color(0.2, 0.3, 0.4);
+                }
+
             },
             OptionPanel::FilamentSettings => {
                 ui.label("b");
@@ -121,14 +129,14 @@ impl SideView {
         }
     }
 
-    pub fn side_panel_ui(&mut self, ctx: &Context) {
+    pub fn side_panel_ui(&mut self, ctx: &Context, view_interface: &mut ResMut<ViewInterface>) {
         let mut tabbed_view = TabbedView::init();
 
         egui::SidePanel::right("settings-panel")
             .resizable(true)
             .default_width(150.0)
             .show(ctx, |ui| {
-                tabbed_view.show(ctx, ui, self);
+                tabbed_view.show(ctx, ui, self, view_interface);
             });
     }
 }
\ No newline at end of file
diff --git a/src/main.rs b/src/main.rs
index d74b013..f06c332 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -2,49 +2,18 @@ mod fiberslice;
 mod view;
 mod component;
 
-use bevy::core_pipeline::clear_color::ClearColorConfig;
-use component::EguiData;
-use fiberslice::screen::Screen;
+use fiberslice::gui::*;
+use fiberslice::*;
 
 use bevy_egui::{EguiContexts, EguiPlugin};
-use image::flat::View;
 use smooth_bevy_cameras::LookTransformPlugin;
 
 use bevy::prelude::*;
-use bevy::window::{PresentMode, WindowResolution};
-use view::{camera::*, ViewInterface};
-
-/*
-fn check_cursor_on_egui_element(
-    mut egui_context: ResMut<EguiContext>,
-    windows: Res<Windows>,
-) {
-    if let Some(cursor_position) = egui_context.ctx().input().mouse().pos {
-        for (_, window) in windows.iter() {
-            let window_size = window.physical_size();
-            if cursor_position.x >= 0.0
-                && cursor_position.x <= window_size.width as f32
-                && cursor_position.y >= 0.0
-                && cursor_position.y <= window_size.height as f32
-            {
-                // Cursor is within the window boundaries, you can perform further checks on specific `egui` elements here
-                println!("Cursor is on an egui element!");
-            }
-        }
-    }
-}
-
- */
+use bevy::window::{PresentMode, WindowResolution, PrimaryWindow};
+use view::camera::CameraPlugin;
 
 fn main() {
-        
-    //let mut view_interface = ViewInterface::new(camera3d);
-
-    let mut fiberslice = FiberSlice::new();
-    let mut egui_data = EguiData::new();
-
-    App::new()
-    .add_plugins(DefaultPlugins.set(WindowPlugin {
+    let window_plugin = WindowPlugin {
         primary_window: Some(Window {
             title: "FiberSlice-3D/5D".into(),
             resolution: WindowResolution::new(1200., 900.),
@@ -56,22 +25,27 @@ fn main() {
             ..default()
         }),
         ..default()
-    }))
+    };
+
+    App::new()
+        .insert_resource(view::ViewInterface::new())
+        .insert_resource(GuiInterface::new())
+        .insert_resource(FiberSlice::new())
+        .add_plugins(DefaultPlugins.set(window_plugin))
         .add_plugin(EguiPlugin)
         .add_plugin(LookTransformPlugin)
         .add_plugin(CameraPlugin::default())
-        .add_startup_system(setup)
+        .add_startup_system(view::light_setup)
+        .add_startup_system(view::camera_setup)
+        .add_startup_system(component_setup)
         .add_startup_system(maximize_window)
-        .add_system(move |contexts: EguiContexts, windows: Query<&mut Window>| {
-            egui_data.check_touch(contexts, windows)
-        })
-        .add_system(move |contexts: EguiContexts| {
-            fiberslice.show_ui(contexts)
-        })
+        .add_system(view::view_frame)
+        .add_system(fiberslice::gui::check_touch)
+        .add_system(ui_frame)
         .run();
 }
 
-fn setup(
+fn component_setup(
     mut commands: Commands,
     mut meshes: ResMut<Assets<Mesh>>,
     mut materials: ResMut<Assets<StandardMaterial>>,
@@ -82,10 +56,7 @@ fn setup(
             size: 5.0,
             subdivisions: 4,
         })),
-        material: materials.add(Color::rgb(
-            rgb_to_one_zero(123.), 
-        rgb_to_one_zero(169.), 
-        rgb_to_one_zero(201.)).into()),
+        material: materials.add(Color::rgb(123./255., 169./255., 201./255.).into()),
         ..Default::default()
     });
 
@@ -97,48 +68,14 @@ fn setup(
         ..Default::default()
     });
 
-    // light
-    commands.spawn(PointLightBundle {
-        transform: Transform::from_xyz(4.0, 8.0, 4.0),
-        ..Default::default()
-    });
-
-    commands.spawn(Camera3dBundle::default())
-        .insert(CameraBundle::new(
-            CameraController::default(),
-            Vec3::new(-2.0, 5.0, 5.0),
-            Vec3::new(0., 0., 0.),
-            Vec3::Y,
-        ));
 }
 
-fn maximize_window(
-    // we have to use `NonSend` here
-    mut windows: Query<&mut Window>,
-) {
+fn maximize_window(mut windows: Query<&mut Window, With<PrimaryWindow>>) {
     let mut window = windows.single_mut();
     window.set_maximized(true);
-} 
-
-fn rgb_to_one_zero(rgb: f32) -> f32 {
-    rgb/255.0
-}
-
-struct FiberSlice {
-    screen: Screen,
-}
-
-impl FiberSlice {
-    fn new(/*_view_interface: ViewInterface*/) -> Self {
-        Self {
-            screen: Screen::new(),
-        }
-    }
 }
 
-impl FiberSlice {
-    fn show_ui(&mut self, mut contexts: EguiContexts) {
-        let ctx = contexts.ctx_mut();
-        self.screen.ui(ctx);
-    }
+fn ui_frame(mut contexts: EguiContexts, mut fiberslice: ResMut<FiberSlice>, mut viewinterface: ResMut<view::ViewInterface>) {
+    let ctx = contexts.ctx_mut();
+    fiberslice.ui_frame(ctx, &mut viewinterface);
 }
\ No newline at end of file
diff --git a/src/view.rs b/src/view.rs
index 1600c5a..8a0c205 100644
--- a/src/view.rs
+++ b/src/view.rs
@@ -1,19 +1,55 @@
-use bevy::{prelude::{Camera3d, Color}, core_pipeline::clear_color::ClearColorConfig};
+use bevy::{prelude::*, core_pipeline::clear_color::ClearColorConfig};
 
 pub mod camera;
 
-pub struct ViewInterface<'a> {
-    camera3d: &'a mut Camera3d,
+#[derive(Resource)]
+pub struct ViewInterface {
+    new_view_color: Option<Color>,
 }
 
-impl <'a> ViewInterface<'a> {
-    pub fn new(camera3d: &'a mut Camera3d) -> Self {
+impl ViewInterface {
+    pub fn new() -> Self {
         Self {
-            camera3d
+            new_view_color: None
         }
     }
 
-    pub fn set_view_color(&self, r: f32, g: f32, b: f32) {
-        
+    pub fn change_view_color(&mut self, r: f32, g: f32, b: f32) {
+        self.new_view_color = Some(Color::rgb(r, g, b));
     }
+
+    pub fn need_view_color_changed(&mut self) -> Option<Color> {
+        self.new_view_color
+    }
+
+    pub fn reset_need_view_color_changed(&mut self) {
+        self.new_view_color = None;
+    }
+}
+
+pub fn view_frame(mut camera_query: Query<&mut Camera3d>, mut view_interface: ResMut<ViewInterface>) {
+    if let Some(color) = view_interface.need_view_color_changed() {
+        view_interface.reset_need_view_color_changed();
+
+        camera_query.for_each_mut(|mut camera| {
+            camera.clear_color = ClearColorConfig::Custom(color)
+        });
+    }
+}
+
+pub fn light_setup(mut commands: Commands) {
+    commands.spawn(PointLightBundle {
+        transform: Transform::from_xyz(4.0, 8.0, 4.0),
+        ..Default::default()
+    });
+}
+
+pub fn camera_setup(mut commands: Commands) {
+    commands.spawn(Camera3dBundle::default())
+        .insert(camera::CameraBundle::new(
+            camera::CameraController::default(),
+            Vec3::new(-2.0, 5.0, 5.0),
+            Vec3::new(0., 0., 0.),
+            Vec3::Y,
+        ));
 }
\ No newline at end of file

