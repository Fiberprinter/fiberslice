commit 5b968f68b105eb8c5692a882fcc1e19c9ab46c39
Author: Elias Gottsbacher <eli.gottsbacher@gmail.com>
Date:   Mon May 29 15:43:51 2023 +0200

    gl - egui implementation

diff --git a/src/component/tabbed_view.rs b/src/component/tabbed_view.rs
index eaefd49..fd7f461 100644
--- a/src/component/tabbed_view.rs
+++ b/src/component/tabbed_view.rs
@@ -1,5 +1,5 @@
 use egui::epaint::ahash::HashMap;
-use egui::Ui;
+use egui::{Align, Direction, Ui};
 
 #[derive(Clone, Copy, PartialEq)]
 pub struct Tab<'a> {
@@ -18,28 +18,46 @@ impl <'a> Tab<'a> {
 
 pub struct TabbedView<'a> {
     tabs: &'a mut Vec<Tab<'a>>,
-    open_tab_index: &'a mut usize,
+    open_tab_index: usize,
 }
 
 impl <'a> TabbedView<'a> {
-    pub fn new(tabs: &'a mut Vec<Tab<'a>>, start_index: &'a mut usize) -> Self {
+    pub fn new(tabs: &'a mut Vec<Tab<'a>>, _start_index: &'a mut usize) -> Self {
 
         Self {
             tabs,
-            open_tab_index: start_index,
+            open_tab_index: 0,
         }
     }
 
     pub fn show(&'a mut self, ui: &'a mut Ui) {
         ui.separator();
+
         ui.horizontal(|ui| {
-            for i in 0..self.tabs.len() {
-                let tab = &mut self.tabs[i];
-                ui.selectable_value(self.open_tab_index, i, tab.title);
-            }
+            //horizontal layout centered each tab
+
+            let layout = egui::Layout {
+                main_dir: Direction::LeftToRight,
+                main_wrap: true,
+                main_align: Align::Center,
+                main_justify: false,
+                cross_align: Align::Center,
+                cross_justify: true,
+            };
+
+            ui.with_layout(layout, |ui| {
+                for i in 0..self.tabs.len() {
+                    let tab = &mut self.tabs[i];
+
+                    ui.selectable_value(&mut self.open_tab_index, i, tab.title);
+                    if (i + 1) < self.tabs.len() {
+                        ui.separator();
+                    }
+                }
+            });
         });
 
         ui.separator();
-        (self.tabs[*self.open_tab_index].show)(ui);
+        (self.tabs[self.open_tab_index].show)(ui);
     }
 }
\ No newline at end of file
diff --git a/src/fiberslice.rs b/src/fiberslice.rs
index d6b1037..af009c4 100644
--- a/src/fiberslice.rs
+++ b/src/fiberslice.rs
@@ -1,27 +1,2 @@
 pub mod utils;
-pub mod window;
-pub mod screen;
-
-pub mod wgpu {
-    use wgpu::{Adapter, Device, Instance, Queue, RequestDeviceError, Surface};
-
-    pub(crate) fn request_wgpu_adapter(instance: &Instance, surface: &Surface) -> Option<Adapter> {
-        pollster::block_on(instance.request_adapter(&wgpu::RequestAdapterOptions {
-            power_preference: wgpu::PowerPreference::HighPerformance,
-            compatible_surface: Some(&surface),
-            force_fallback_adapter: false,
-        }))
-    }
-
-    pub(crate) fn request_wgpu_device(adapter: &Adapter) -> Result<(Device, Queue), RequestDeviceError> {
-        pollster::block_on(adapter.request_device(
-            &wgpu::DeviceDescriptor {
-                features: wgpu::Features::default(),
-                limits: wgpu::Limits::default(),
-                label: None,
-            },
-            None,
-        ))
-    }
-
-}
\ No newline at end of file
+pub mod screen;
\ No newline at end of file
diff --git a/src/fiberslice/screen.rs b/src/fiberslice/screen.rs
index 1f9b46a..7c5cb20 100644
--- a/src/fiberslice/screen.rs
+++ b/src/fiberslice/screen.rs
@@ -1,6 +1,8 @@
 mod side;
 mod view;
 
+use std::sync::Arc;
+use eframe::CreationContext;
 use egui::{Context, Modifiers, Ui};
 use egui::WidgetType::Slider;
 use crate::fiberslice::screen::menu::menubar_ui;
@@ -8,74 +10,102 @@ use crate::fiberslice::screen::menu::menubar_ui;
 mod menu {
     use egui::{Context, Ui};
 
-    pub fn menubar_ui(ctx: &Context) {
+    pub fn menubar_ui(ctx: &Context, screen: &mut super::Screen) {
         egui::TopBottomPanel::top("menu_bar").show(ctx, |ui| {
             egui::menu::bar(ui, |ui| {
-                file_button(ui);
-                edit_button(ui);
-                window_button(ui);
-                view_button(ui);
-                settings_button(ui);
-                help_button(ui);
+                theme_button(ui, screen);
+                ui.separator();
+                file_button(ui, screen);
+                edit_button(ui, screen);
+                view_button(ui, screen);
+                settings_button(ui, screen);
+                help_button(ui, screen);
             });
         });
     }
 
-    fn file_button(ui: &mut Ui) {
+    fn file_button(ui: &mut Ui, screen: &mut super::Screen) {
         ui.menu_button("File", |ui| {
             ui.set_min_width(220.0);
             ui.style_mut().wrap = Some(false);
         });
     }
 
-    fn edit_button(ui: &mut Ui) {
+    fn edit_button(ui: &mut Ui, screen: &mut super::Screen) {
         ui.menu_button("Edit", |ui| {
             ui.set_min_width(220.0);
             ui.style_mut().wrap = Some(false);
         });
     }
 
-    fn window_button(ui: &mut Ui) {
-        ui.menu_button("Window", |ui| {
-            ui.set_min_width(220.0);
-            ui.style_mut().wrap = Some(false);
-        });
-    }
-
-    fn view_button(ui: &mut Ui) {
+    fn view_button(ui: &mut Ui, screen: &mut super::Screen) {
         ui.menu_button("View", |ui| {
             ui.set_min_width(220.0);
             ui.style_mut().wrap = Some(false);
         });
     }
 
-    fn settings_button(ui: &mut Ui) {
+    fn settings_button(ui: &mut Ui, screen: &mut super::Screen) {
         ui.menu_button("Settings", |ui| {
             ui.set_min_width(220.0);
             ui.style_mut().wrap = Some(false);
         });
     }
 
-    fn help_button(ui: &mut Ui) {
+    fn help_button(ui: &mut Ui, screen: &mut super::Screen) {
         ui.menu_button("Help", |ui| {
             ui.set_min_width(220.0);
             ui.style_mut().wrap = Some(false);
         });
     }
+
+    fn theme_button(ui: &mut Ui, screen: &mut super::Screen) {
+        let clicked = match screen.toggle_theme {
+            true => ui.button("ðŸ’¡").clicked().clone(),
+            false => ui.button("ðŸŒ™").clicked().clone(),
+        };
+
+        if screen.toggle_theme {
+            handle_toggle_theme(ui,clicked, screen);
+        } else {
+            handle_toggle_theme(ui, clicked, screen);
+        }
+    }
+
+    fn handle_toggle_theme(ui: &mut Ui, toggle: bool, screen: &mut super::Screen) {
+        if toggle {
+            screen.toggle_theme = !screen.toggle_theme;
+
+            if screen.toggle_theme {
+                ui.ctx().set_visuals(egui::Visuals::dark());
+            } else {
+                ui.ctx().set_visuals(egui::Visuals::light());
+            }
+        }
+    }
 }
 
 pub struct Screen {
+    toggle_theme: bool,
+    side_view_data: side::SideView,
+    view_data: view::View,
 }
 
 impl Screen {
-    pub fn new() -> Screen {
-        Screen {
-        }
+    pub fn new(cc: &CreationContext) -> Screen {
+
+        let screen = Screen {
+            toggle_theme: true,
+            side_view_data: side::SideView::init(),
+            view_data: view::View::init(cc),
+        };
+
+        screen
     }
 
     pub(crate) fn ui(&mut self, ctx: &Context) {
-        menubar_ui(ctx);
-        side::side_panel_ui(ctx);
-        view::view_panel_ui(ctx);
+        menubar_ui(ctx, self);
+        self.side_view_data.side_panel_ui(ctx);
+        self.view_data.view_panel_ui(ctx);
     }
 }
\ No newline at end of file
diff --git a/src/fiberslice/screen/side.rs b/src/fiberslice/screen/side.rs
index 9511fff..66d4336 100644
--- a/src/fiberslice/screen/side.rs
+++ b/src/fiberslice/screen/side.rs
@@ -1,43 +1,134 @@
-use egui::Context;
-use crate::component::tabbed_view::*;
-
-pub fn side_panel_ui(ctx: &Context) {
-    egui::SidePanel::right("egui_demo_panel")
-        .resizable(true)
-        .default_width(150.0)
-        .show(ctx, |ui| {
-            let mut tabs = vec![
-                Tab::new("Slice Settings", |ui| {
-                    ui.label("This is the content of tab 1");
-                }),
-                Tab::new("Filament Settings", |ui| {
-                    ui.label("This is the content of tab 2");
-                }),
-                Tab::new("Printer Settings", |ui| {
-                    ui.label("This is the content of tab 3");
-                }),
-            ];
-
-            let mut start_index = 0;
-            let mut tabview = TabbedView::new(&mut tabs, &mut start_index);
-
-            tabview.show(ui);
-            /*
-            TabBar::new("Options").show(ui, |ui| {
-                // Add a tab page
-                TabPage::new("Slice Settings").show(ui, |ui| {
-                    ui.label("This is the content of tab 1");
-                });
+use eframe::emath::Align;
+use egui::{Context, Direction, Margin, Ui};
+use egui_grid::GridBuilder;
+use egui_extras::Size;
 
-                TabPage::new("Filament Settings").show(ui, |ui| {
-                    ui.label("This is the content of tab 2");
-                });
+#[derive(PartialEq)]
+pub enum OptionPanel {
+    SliceSettings,
+    FilamentSettings,
+    PrinterSettings,
+}
+
+struct TabbedView {
+}
+
+impl TabbedView {
+    pub fn init() -> Self {
+        Self {
+        }
+    }
 
-                // Add another tab page
-                TabPage::new("Printer Settings").show(ui, |ui| {
-                    ui.label("This is the content of tab 2");
+    pub fn show(&mut self, ctx: &Context, ui: &mut Ui, side_view: &mut SideView) {
+        ui.horizontal(|ui| {
+            let layout = egui::Layout {
+                main_dir: Direction::TopDown,
+                main_wrap: false,
+                main_align: Align::Center,
+                main_justify: false,
+                cross_align: Align::Center,
+                cross_justify: true,
+            };
+
+            GridBuilder::new()
+                // Allocate a new row
+                .new_row_align(Size::initial(17.0), Align::Center)
+                // Give this row a couple cells
+                .layout_standard(layout)
+                .clip(true)
+                .cell(Size::remainder())
+                .cell(Size::initial(5.0))
+                .cell(Size::remainder())
+                .cell(Size::initial(5.0))
+                .cell(Size::remainder())
+                .new_row_align(Size::initial(5.0), Align::Center)
+                .cell(Size::remainder())
+                .cell(Size::remainder())
+                .cell(Size::remainder())
+                .show(ui, |mut grid| {
+                    // Cells are represented as they were allocated
+                    grid.cell(|ui| {
+                        ui.selectable_value(&mut side_view.open_panel, OptionPanel::SliceSettings, "Slice Settings");
+                    });
+                    grid.cell(|ui| {
+                        ui.horizontal(|ui| {
+                            ui.separator();
+                        });
+                    });
+                    grid.cell(|ui| {
+                        ui.selectable_value(&mut side_view.open_panel, OptionPanel::FilamentSettings, "Filament Settings");
+                    });
+                    grid.cell(|ui| {
+                        ui.horizontal(|ui| {
+                            ui.separator();
+                        });
+                    });
+                    grid.cell(|ui| {
+                        ui.selectable_value(&mut side_view.open_panel, OptionPanel::PrinterSettings, "Printer Settings");
+                    });
+                    grid.cell(|ui| {
+                        ui.vertical(|ui| {
+                            if side_view.open_panel != OptionPanel::SliceSettings {
+                                ui.separator();
+                            }
+                        });
+                    });
+                    grid.cell(|ui| {
+                        ui.vertical(|ui| {
+                            if side_view.open_panel != OptionPanel::FilamentSettings {
+                                ui.separator();
+                            }
+                        });
+                    });
+                    grid.cell(|ui| {
+                        ui.vertical(|ui| {
+                            if side_view.open_panel != OptionPanel::PrinterSettings {
+                                ui.separator();
+                            }
+                        });
+                    });
                 });
-            });
-             */
         });
+
+        ui.add_space(20.0 );
+
+        match side_view.open_panel {
+            OptionPanel::SliceSettings => {
+                ui.label("a");
+            },
+            OptionPanel::FilamentSettings => {
+                ui.label("b");
+            },
+            OptionPanel::PrinterSettings => {
+                ui.label("c");
+            },
+            _ => {
+
+            }
+        }
+    }
+}
+
+pub(crate) struct SideView {
+    open_panel: OptionPanel,
+}
+
+
+impl SideView {
+    pub fn init() -> SideView {
+        SideView {
+            open_panel: OptionPanel::SliceSettings,
+        }
+    }
+
+    pub fn side_panel_ui(&mut self, ctx: &Context) {
+        let mut tabbed_view = TabbedView::init();
+
+        egui::SidePanel::right("settings-panel")
+            .resizable(true)
+            .default_width(150.0)
+            .show(ctx, |ui| {
+                tabbed_view.show(ctx, ui, self);
+            });
+    }
 }
\ No newline at end of file
diff --git a/src/fiberslice/screen/view.rs b/src/fiberslice/screen/view.rs
index 49797e0..243b745 100644
--- a/src/fiberslice/screen/view.rs
+++ b/src/fiberslice/screen/view.rs
@@ -1,8 +1,224 @@
-use egui::Context;
+mod options;
 
-pub fn view_panel_ui(ctx: &Context) {
-    egui::CentralPanel::default()
-        .show(ctx, |ui| {
+use egui::{CollapsingHeader, Context, Margin, Ui};
+use std::sync::Arc;
 
+use eframe::{egui_glow, Frame};
+use eframe::epaint::Stroke;
+use egui::mutex::Mutex;
+use egui_glow::glow;
+use crate::fiberslice::screen::view::options::LeftOptionPane;
+
+
+pub(crate) struct View {
+    object_view: ObjectView,
+    left_option_pane: LeftOptionPane,
+}
+
+impl View {
+    pub fn init(cc: &eframe::CreationContext) -> Self {
+
+        let mut object_view = ObjectView::new();
+        object_view.init_gl(cc.gl.as_ref().unwrap());
+
+        let option_pane = LeftOptionPane::default();
+
+        Self {
+            object_view,
+            left_option_pane: option_pane
+        }
+    }
+
+    pub fn view_panel_ui(&mut self, ctx: &Context) {
+        egui::CentralPanel::default()
+            .frame(egui::Frame::dark_canvas(&ctx.style()))
+            .show(ctx, |ui| {
+                self.left_option_pane.ui(ctx, ui);
+                self.object_view.ui(ctx, ui);
+            });
+    }
+
+    pub fn get_left_option_pane(&mut self) -> &mut LeftOptionPane {
+        &mut self.left_option_pane
+    }
+}
+
+pub struct ObjectView {
+    /// Behind an `Arc<Mutex<â€¦>>` so we can pass it to [`egui::PaintCallback`] and paint later.
+    rotating_triangle: Option<Arc<Mutex<RotatingTriangle>>>,
+    angle: f32,
+}
+
+impl ObjectView {
+    pub fn new() -> Self {
+        Self {
+            rotating_triangle: None,
+            angle: 0.0,
+        }
+    }
+
+    pub fn init_gl(&mut self, gl: &glow::Context) {
+        self.rotating_triangle = Some(Arc::new(Mutex::new(RotatingTriangle::new(gl))));
+    }
+
+    fn ui(&mut self, ctx: &Context, ui: &mut egui::Ui) {
+        egui::CentralPanel::default()
+            .show(ctx, |ui| {
+                self.paint(ui);
+            });
+    }
+
+    fn paint(&mut self, ui: &mut Ui) {
+        let (rect, response) =
+            ui.allocate_exact_size(egui::Vec2::splat(300.0), egui::Sense::drag());
+
+        self.angle += response.drag_delta().x * 0.01;
+
+        // Clone locals so we can move them into the paint callback:
+        let angle = self.angle;
+        let rotating_triangle = self.rotating_triangle.clone().unwrap();
+
+        let cb = egui_glow::CallbackFn::new(move |_info, painter| {
+            rotating_triangle.lock().paint(painter.gl(), angle);
         });
-}
\ No newline at end of file
+
+        let callback = egui::PaintCallback {
+            rect,
+            callback: Arc::new(cb),
+        };
+        ui.painter().add(callback);
+    }
+
+    fn on_exit(&mut self, gl: Option<&glow::Context>) {
+        if let Some(gl) = gl {
+            self.rotating_triangle.as_ref().unwrap().lock().destroy(gl);
+        }
+    }
+}
+
+struct RotatingTriangle {
+    program: glow::Program,
+    vertex_array: glow::VertexArray,
+}
+
+#[allow(unsafe_code)] // we need unsafe code to use glow
+impl RotatingTriangle {
+    fn new(gl: &glow::Context) -> Self {
+        use glow::HasContext as _;
+
+        let shader_version = egui_glow::ShaderVersion::get(gl);
+
+        unsafe {
+            let program = gl.create_program().expect("Cannot create program");
+
+            /*
+            if !shader_version.is_new_shader_interface() {
+
+            }
+             */
+
+            let (vertex_shader_source, fragment_shader_source) = (
+                r#"
+                    const vec2 verts[3] = vec2[3](
+                        vec2(0.0, 1.0),
+                        vec2(-1.0, -1.0),
+                        vec2(1.0, -1.0)
+                    );
+                    const vec4 colors[3] = vec4[3](
+                        vec4(1.0, 0.0, 0.0, 1.0),
+                        vec4(0.0, 1.0, 0.0, 1.0),
+                        vec4(0.0, 0.0, 1.0, 1.0)
+                    );
+                    out vec4 v_color;
+                    uniform float u_angle;
+                    void main() {
+                        v_color = colors[gl_VertexID];
+                        gl_Position = vec4(verts[gl_VertexID], 0.0, 1.0);
+                        gl_Position.x *= cos(u_angle);
+                    }
+                "#,
+                r#"
+                    precision mediump float;
+                    in vec4 v_color;
+                    out vec4 out_color;
+                    void main() {
+                        out_color = v_color;
+                    }
+                "#,
+            );
+
+            let shader_sources = [
+                (glow::VERTEX_SHADER, vertex_shader_source),
+                (glow::FRAGMENT_SHADER, fragment_shader_source),
+            ];
+
+            let shaders: Vec<_> = shader_sources
+                .iter()
+                .map(|(shader_type, shader_source)| {
+                    let shader = gl
+                        .create_shader(*shader_type)
+                        .expect("Cannot create shader");
+                    gl.shader_source(
+                        shader,
+                        &format!(
+                            "{}\n{}",
+                            shader_version.version_declaration(),
+                            shader_source
+                        ),
+                    );
+                    gl.compile_shader(shader);
+                    assert!(
+                        gl.get_shader_compile_status(shader),
+                        "Failed to compile custom_3d_glow {shader_type}: {}",
+                        gl.get_shader_info_log(shader)
+                    );
+
+                    gl.attach_shader(program, shader);
+                    shader
+                })
+                .collect();
+
+            gl.link_program(program);
+            assert!(
+                gl.get_program_link_status(program),
+                "{}",
+                gl.get_program_info_log(program)
+            );
+
+            for shader in shaders {
+                gl.detach_shader(program, shader);
+                gl.delete_shader(shader);
+            }
+
+            let vertex_array = gl
+                .create_vertex_array()
+                .expect("Cannot create vertex array");
+
+            Self {
+                program,
+                vertex_array,
+            }
+        }
+    }
+
+    fn destroy(&self, gl: &glow::Context) {
+        use glow::HasContext as _;
+        unsafe {
+            gl.delete_program(self.program);
+            gl.delete_vertex_array(self.vertex_array);
+        }
+    }
+
+    fn paint(&self, gl: &glow::Context, angle: f32) {
+        use glow::HasContext as _;
+        unsafe {
+            gl.use_program(Some(self.program));
+            gl.uniform_1_f32(
+                gl.get_uniform_location(self.program, "u_angle").as_ref(),
+                angle,
+            );
+            gl.bind_vertex_array(Some(self.vertex_array));
+            gl.draw_arrays(glow::TRIANGLES, 0, 3);
+        }
+    }
+}
diff --git a/src/fiberslice/screen/view/options.rs b/src/fiberslice/screen/view/options.rs
new file mode 100644
index 0000000..a17cd6a
--- /dev/null
+++ b/src/fiberslice/screen/view/options.rs
@@ -0,0 +1,53 @@
+
+use egui::{CollapsingHeader, Context, Frame, Stroke, Ui};
+
+#[derive(PartialEq, Clone)]
+pub enum Face {
+    DEFAULT,
+    TOP,
+    BOTTOM,
+    RIGHT,
+    LEFT,
+    FRONT,
+    BACK
+}
+
+pub struct LeftOptionPane {
+    face: Option<Face>
+}
+
+impl Default for LeftOptionPane {
+    fn default() -> Self {
+        Self {
+            face: Some(Face::DEFAULT)
+        }
+    }
+}
+
+impl LeftOptionPane {
+    pub fn ui(&mut self, ctx: &Context, ui: &mut Ui) {
+        Frame::popup(ui.style())
+            .stroke(Stroke::NONE)
+            .show(ui, |ui| {
+                ui.set_max_width(270.0);
+                CollapsingHeader::new("Settings")
+                    .show(ui, |ui| {
+                        ui.label("test");
+                    });
+            });
+    }
+
+    pub fn get_face(&self) -> Option<Face> {
+        self.face.clone()
+    }
+
+    pub fn set_face(&mut self, face: Face) {
+        self.face = Some(face);
+    }
+}
+
+/*
+struct RightOptionPane {
+
+}
+ */
\ No newline at end of file
diff --git a/src/fiberslice/window.rs b/src/fiberslice/window.rs
deleted file mode 100644
index 392dcc3..0000000
--- a/src/fiberslice/window.rs
+++ /dev/null
@@ -1,75 +0,0 @@
-use wgpu::{Device, Surface, SurfaceConfiguration};
-use winit::event::WindowEvent;
-use winit::event_loop::ControlFlow;
-use winit::window::Window;
-
-#[allow(dead_code)]
-pub struct WindowEventObserver<'a> {
-    window: &'a Window,
-}
-
-pub struct FiberSliceWindow<'a> {
-    window: &'a Window,
-    device: &'a Device,
-    surface: &'a Surface,
-    surface_config: &'a mut SurfaceConfiguration,
-}
-
-impl <'a> WindowEventObserver<'a> {
-
-    pub fn new(window: &'a Window) -> Self {
-        WindowEventObserver {
-            window
-        }
-    }
-
-    pub fn call_event(&self, event: WindowEvent, fiber_slice_window: &mut FiberSliceWindow, control_flow: &mut ControlFlow) {
-        match event {
-            WindowEvent::Resized(size) => {
-                // Resize with 0 width and height is used by winit to signal a minimize event on Windows.
-                // See: https://github.com/rust-windowing/winit/issues/208
-                // This solves an issue where the app would panic when minimizing on Windows.
-                if size.width > 0 && size.height > 0 {
-                    fiber_slice_window.surface_config.width = size.width;
-                    fiber_slice_window.surface_config.height = size.height;
-                    fiber_slice_window.surface.configure(fiber_slice_window.device, fiber_slice_window.surface_config);
-                }
-            }
-            WindowEvent::CloseRequested => {
-                *control_flow = ControlFlow::Exit;
-            }
-            _ => {
-
-            }
-        }
-    }
-}
-
-#[allow(dead_code)]
-impl <'a> FiberSliceWindow<'a> {
-
-    pub fn new(window: &'a Window, device: &'a Device, surface: &'a Surface, surface_config: &'a mut SurfaceConfiguration) -> Self {
-        FiberSliceWindow {
-            window,
-            device,
-            surface,
-            surface_config,
-        }
-    }
-
-    pub fn get_window(&self) -> &Window {
-        self.window
-    }
-
-    pub fn get_surface(&self) -> &Surface {
-        self.surface
-    }
-
-    pub fn get_surface_config(&self) -> &SurfaceConfiguration {
-        self.surface_config
-    }
-
-    pub fn get_device(&self) -> &Device {
-        self.device
-    }
-}
\ No newline at end of file
diff --git a/src/main.rs b/src/main.rs
index fdd1dc3..07dbdd4 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,138 +1,39 @@
-mod window_builder;
 mod fiberslice;
 mod component;
 
-use std::iter;
-use std::time::Instant;
-
-use egui::FontDefinitions;
-use egui_wgpu_backend::{RenderPass, ScreenDescriptor};
-use egui_winit_platform::{Platform, PlatformDescriptor};
-use wgpu::{InstanceDescriptor, TextureFormat};
-use winit::event::Event::*;
-use winit::event_loop::{EventLoop};
-use winit::window::Window;
-
-use window_builder::{create_winit_window, Event};
-use fiberslice::wgpu::request_wgpu_adapter;
-use fiberslice::utils::Creation;
-use fiberslice::wgpu::request_wgpu_device;
-use fiberslice::window::WindowEventObserver;
-use fiberslice::window::FiberSliceWindow;
+use std::sync::Arc;
+use eframe::egui;
+use egui_glow::glow::Context;
 use fiberslice::screen::Screen;
 
 fn main() {
-    let event_loop = EventLoop::create();
-    let window: Window = create_winit_window(&event_loop);
-
-    let instance = wgpu::Instance::new(InstanceDescriptor::default());
-    let surface = unsafe { instance.create_surface(&window).unwrap() };
-
-    let adapter = request_wgpu_adapter(&instance, &surface).unwrap();
-
-    let (device, queue) = request_wgpu_device(&adapter).unwrap();
-
-    let size = window.inner_size();
-
-    let texture_format = TextureFormat::Bgra8UnormSrgb;
-    let mut surface_config = wgpu::SurfaceConfiguration {
-        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
-        format: texture_format,
-        width: size.width as u32,
-        height: size.height as u32,
-        present_mode: wgpu::PresentMode::Fifo,
-        alpha_mode: Default::default(),
-        view_formats: Default::default(),
-    };
-    surface.configure(&device, &surface_config);
-
-    let mut platform = Platform::new(PlatformDescriptor {
-        physical_width: size.width as u32,
-        physical_height: size.height as u32,
-        scale_factor: window.scale_factor(),
-        font_definitions: FontDefinitions::default(),
-        style: Default::default(),
-    });
-
-    let mut egui_rpass = RenderPass::new(&device, texture_format, 1);
-
-    let mut screen = Screen::new();
-    let start_time = Instant::now();
-
-    let mut demo_app = egui_demo_lib::DemoWindows::default();
-
-    event_loop.run(move |event, _, control_flow| {
-        platform.handle_event(&event);
-
-        let mut fiberslice_window = FiberSliceWindow::new(&window, &device, &surface, &mut surface_config);
-        let window_event_observer = WindowEventObserver::new(&window);
-
-        match event {
-            RedrawRequested(..) => {
-                platform.update_time(start_time.elapsed().as_secs_f64());
-
-                let output_frame = match surface.get_current_texture() {
-                    Ok(frame) => frame,
-                    Err(wgpu::SurfaceError::Outdated) => {
-                        return;
-                    }
-                    Err(e) => {
-                        eprintln!("Dropped frame with error: {}", e);
-                        return;
-                    }
-                };
-                let output_view = output_frame
-                    .texture
-                    .create_view(&wgpu::TextureViewDescriptor::default());
-
-                platform.begin_frame();
-
-
-                screen.ui(&platform.context());
-
-                let full_output = platform.end_frame(Some(&window));
-                let paint_jobs = platform.context().tessellate(full_output.shapes);
-
-                let mut encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
-                    label: Some("encoder"),
-                });
-
-                let screen_descriptor = ScreenDescriptor {
-                    physical_width: fiberslice_window.get_surface_config().width,
-                    physical_height: fiberslice_window.get_surface_config().height,
-                    scale_factor: window.scale_factor() as f32,
-                };
-                let tdelta: egui::TexturesDelta = full_output.textures_delta;
-                egui_rpass
-                    .add_textures(&device, &queue, &tdelta)
-                    .expect("add texture ok");
-                egui_rpass.update_buffers(&device, &queue, &paint_jobs, &screen_descriptor);
-
-                egui_rpass
-                    .execute(
-                        &mut encoder,
-                        &output_view,
-                        &paint_jobs,
-                        &screen_descriptor,
-                        Some(wgpu::Color::BLACK),
-                    )
-                    .unwrap();
-
-                queue.submit(iter::once(encoder.finish()));
-
-                output_frame.present();
-
-                egui_rpass
-                    .remove_textures(tdelta)
-                    .expect("remove texture ok");
-            }
-            MainEventsCleared | UserEvent(Event::RequestRedraw) => {
-                window.request_redraw();
-            }
-            WindowEvent { event, .. } => {
-                window_event_observer.call_event(event, &mut fiberslice_window, control_flow);
-            },
-            _ => (),
+    let native_options = eframe::NativeOptions::default();
+    eframe::run_native("FiberSlice",
+                       native_options,
+                       Box::new(|cc|
+                           Box::new(FiberSlice::new(cc))))
+        .expect("Something went wrong while creating the frame");
+}
+
+struct FiberSlice {
+    screen: Screen,
+}
+
+impl FiberSlice {
+    fn new(cc: &eframe::CreationContext) -> Self {
+        // Customize egui here with cc.egui_ctx.set_fonts and cc.egui_ctx.set_visuals.
+        // Restore app state using cc.storage (requires the "persistence" feature).
+        // Use the cc.gl (a glow::Context) to create graphics shaders and buffers that you can use
+        // for e.g. egui::PaintCallback.
+
+        Self {
+            screen: Screen::new(cc),
         }
-    });
+    }
+}
+
+impl eframe::App for FiberSlice {
+    fn update(&mut self, ctx: &egui::Context, frame: &mut eframe::Frame) {
+        self.screen.ui(ctx);
+    }
 }
\ No newline at end of file
diff --git a/src/window_builder.rs b/src/window_builder.rs
deleted file mode 100644
index d6b1a71..0000000
--- a/src/window_builder.rs
+++ /dev/null
@@ -1,38 +0,0 @@
-use winit::event_loop::EventLoop;
-use winit::window::Window;
-use crate::fiberslice::utils::Creation;
-
-const INITIAL_WIDTH: u32 = 1920;
-const INITIAL_HEIGHT: u32 = 1080;
-
-pub enum Event {
-    RequestRedraw,
-}
-
-pub struct DefaultRepaintSignal(std::sync::Mutex<winit::event_loop::EventLoopProxy<Event>>);
-
-impl epi::backend::RepaintSignal for DefaultRepaintSignal {
-    fn request_repaint(&self) {
-        self.0.lock().unwrap().send_event(Event::RequestRedraw).ok();
-    }
-}
-
-pub fn create_winit_window(event_loop: &EventLoop<Event>) -> Window {
-    winit::window::WindowBuilder::new()
-        .with_decorations(true)
-        .with_resizable(true)
-        .with_transparent(false)
-        .with_title("FiberSlice 5D")
-        .with_inner_size(winit::dpi::PhysicalSize {
-            width: INITIAL_WIDTH,
-            height: INITIAL_HEIGHT,
-        })
-        .build(&event_loop)
-        .unwrap()
-}
-
-impl Creation for EventLoop<Event> {
-    fn create() -> Self {
-        winit::event_loop::EventLoopBuilder::<Event>::with_user_event().build()
-    }
-}
\ No newline at end of file

