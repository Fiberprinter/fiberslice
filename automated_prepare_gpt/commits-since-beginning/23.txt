commit 772f381c98a8140f16d5a523c5f1812060dbad25
Author: GodGotzi <eli.gottsbacher@gmail.com>
Date:   Tue May 30 23:19:40 2023 +0200

    bevy camera / egui

diff --git a/src/component.rs b/src/component.rs
index 2cf47c7..9783b27 100644
--- a/src/component.rs
+++ b/src/component.rs
@@ -1 +1,41 @@
-pub(crate) mod tabbed_view;
\ No newline at end of file
+use std::fmt::Display;
+
+use bevy::{window::Window, prelude::Query};
+use bevy_egui::{EguiContexts, egui::{Order, LayerId, Id}};
+
+pub struct EguiData {
+    touch: bool    
+}
+
+impl EguiData {
+
+    pub fn new() -> Self {
+        Self {
+            touch: false
+        }
+    }
+
+    pub fn is_touch(&self) -> bool {
+        self.touch
+    }
+
+    pub fn check_touch(
+        &mut self, 
+        mut contexts: EguiContexts, 
+        mut windows: Query<&mut Window>
+    ) {
+        let ctx = contexts.ctx_mut();
+
+        let pointer_pos = ctx.input(|i| i.pointer.interact_pos());
+        if let Some(pointer_pos) = pointer_pos {
+            if let Some(layer) = ctx.layer_id_at(pointer_pos) {
+                println!("{}", layer.order.short_debug_format());
+            } else {
+                self.touch = false
+            }
+        } else {
+            self.touch = false
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/component/tabbed_view.rs b/src/component/tabbed_view.rs
deleted file mode 100644
index fd7f461..0000000
--- a/src/component/tabbed_view.rs
+++ /dev/null
@@ -1,63 +0,0 @@
-use egui::epaint::ahash::HashMap;
-use egui::{Align, Direction, Ui};
-
-#[derive(Clone, Copy, PartialEq)]
-pub struct Tab<'a> {
-    title: &'a str,
-    show: fn(&'a mut Ui),
-}
-
-impl <'a> Tab<'a> {
-    pub fn new(title: &'a str, show: fn(&'a mut Ui)) -> Self {
-        Self {
-            title,
-            show,
-        }
-    }
-}
-
-pub struct TabbedView<'a> {
-    tabs: &'a mut Vec<Tab<'a>>,
-    open_tab_index: usize,
-}
-
-impl <'a> TabbedView<'a> {
-    pub fn new(tabs: &'a mut Vec<Tab<'a>>, _start_index: &'a mut usize) -> Self {
-
-        Self {
-            tabs,
-            open_tab_index: 0,
-        }
-    }
-
-    pub fn show(&'a mut self, ui: &'a mut Ui) {
-        ui.separator();
-
-        ui.horizontal(|ui| {
-            //horizontal layout centered each tab
-
-            let layout = egui::Layout {
-                main_dir: Direction::LeftToRight,
-                main_wrap: true,
-                main_align: Align::Center,
-                main_justify: false,
-                cross_align: Align::Center,
-                cross_justify: true,
-            };
-
-            ui.with_layout(layout, |ui| {
-                for i in 0..self.tabs.len() {
-                    let tab = &mut self.tabs[i];
-
-                    ui.selectable_value(&mut self.open_tab_index, i, tab.title);
-                    if (i + 1) < self.tabs.len() {
-                        ui.separator();
-                    }
-                }
-            });
-        });
-
-        ui.separator();
-        (self.tabs[self.open_tab_index].show)(ui);
-    }
-}
\ No newline at end of file
diff --git a/src/fiberslice/screen.rs b/src/fiberslice/screen.rs
index 0dc10d0..055597e 100644
--- a/src/fiberslice/screen.rs
+++ b/src/fiberslice/screen.rs
@@ -1,10 +1,10 @@
 mod side;
 
-use bevy_egui::egui;
+use bevy_egui::egui::{self, LayerId, Id};
 use crate::fiberslice::screen::menu::menubar_ui;
 
 mod menu {
-    use bevy_egui::egui;
+    use bevy_egui::egui::{self, LayerId, Id};
     use egui::Ui;
 
     pub fn menubar_ui(ctx: &egui::Context, screen: &mut super::Screen) {
diff --git a/src/main.rs b/src/main.rs
index 67bf8b1..d74b013 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,17 +1,47 @@
 mod fiberslice;
 mod view;
+mod component;
 
+use bevy::core_pipeline::clear_color::ClearColorConfig;
+use component::EguiData;
 use fiberslice::screen::Screen;
 
 use bevy_egui::{EguiContexts, EguiPlugin};
+use image::flat::View;
 use smooth_bevy_cameras::LookTransformPlugin;
 
 use bevy::prelude::*;
 use bevy::window::{PresentMode, WindowResolution};
-use view::camera::*;
+use view::{camera::*, ViewInterface};
+
+/*
+fn check_cursor_on_egui_element(
+    mut egui_context: ResMut<EguiContext>,
+    windows: Res<Windows>,
+) {
+    if let Some(cursor_position) = egui_context.ctx().input().mouse().pos {
+        for (_, window) in windows.iter() {
+            let window_size = window.physical_size();
+            if cursor_position.x >= 0.0
+                && cursor_position.x <= window_size.width as f32
+                && cursor_position.y >= 0.0
+                && cursor_position.y <= window_size.height as f32
+            {
+                // Cursor is within the window boundaries, you can perform further checks on specific `egui` elements here
+                println!("Cursor is on an egui element!");
+            }
+        }
+    }
+}
+
+ */
 
 fn main() {
+        
+    //let mut view_interface = ViewInterface::new(camera3d);
+
     let mut fiberslice = FiberSlice::new();
+    let mut egui_data = EguiData::new();
 
     App::new()
     .add_plugins(DefaultPlugins.set(WindowPlugin {
@@ -29,9 +59,12 @@ fn main() {
     }))
         .add_plugin(EguiPlugin)
         .add_plugin(LookTransformPlugin)
-        .add_plugin(OrbitCameraPlugin::default())
+        .add_plugin(CameraPlugin::default())
         .add_startup_system(setup)
         .add_startup_system(maximize_window)
+        .add_system(move |contexts: EguiContexts, windows: Query<&mut Window>| {
+            egui_data.check_touch(contexts, windows)
+        })
         .add_system(move |contexts: EguiContexts| {
             fiberslice.show_ui(contexts)
         })
@@ -43,14 +76,16 @@ fn setup(
     mut meshes: ResMut<Assets<Mesh>>,
     mut materials: ResMut<Assets<StandardMaterial>>,
 ) {
-
     // plane
     commands.spawn(PbrBundle {
         mesh: meshes.add(Mesh::from(shape::Plane {
             size: 5.0,
             subdivisions: 4,
         })),
-        material: materials.add(Color::rgb(0.3, 0.5, 0.3).into()),
+        material: materials.add(Color::rgb(
+            rgb_to_one_zero(123.), 
+        rgb_to_one_zero(169.), 
+        rgb_to_one_zero(201.)).into()),
         ..Default::default()
     });
 
@@ -68,10 +103,9 @@ fn setup(
         ..Default::default()
     });
 
-    commands
-        .spawn(Camera3dBundle::default())
-        .insert(OrbitCameraBundle::new(
-            OrbitCameraController::default(),
+    commands.spawn(Camera3dBundle::default())
+        .insert(CameraBundle::new(
+            CameraController::default(),
             Vec3::new(-2.0, 5.0, 5.0),
             Vec3::new(0., 0., 0.),
             Vec3::Y,
@@ -86,12 +120,16 @@ fn maximize_window(
     window.set_maximized(true);
 } 
 
+fn rgb_to_one_zero(rgb: f32) -> f32 {
+    rgb/255.0
+}
+
 struct FiberSlice {
     screen: Screen,
 }
 
 impl FiberSlice {
-    fn new() -> Self {
+    fn new(/*_view_interface: ViewInterface*/) -> Self {
         Self {
             screen: Screen::new(),
         }
@@ -101,7 +139,6 @@ impl FiberSlice {
 impl FiberSlice {
     fn show_ui(&mut self, mut contexts: EguiContexts) {
         let ctx = contexts.ctx_mut();
-
         self.screen.ui(ctx);
     }
 }
\ No newline at end of file
diff --git a/src/view.rs b/src/view.rs
index 2cee3eb..1600c5a 100644
--- a/src/view.rs
+++ b/src/view.rs
@@ -1 +1,19 @@
-pub mod camera;
\ No newline at end of file
+use bevy::{prelude::{Camera3d, Color}, core_pipeline::clear_color::ClearColorConfig};
+
+pub mod camera;
+
+pub struct ViewInterface<'a> {
+    camera3d: &'a mut Camera3d,
+}
+
+impl <'a> ViewInterface<'a> {
+    pub fn new(camera3d: &'a mut Camera3d) -> Self {
+        Self {
+            camera3d
+        }
+    }
+
+    pub fn set_view_color(&self, r: f32, g: f32, b: f32) {
+        
+    }
+}
\ No newline at end of file
diff --git a/src/view/camera.rs b/src/view/camera.rs
index 8903d6d..48872c2 100644
--- a/src/view/camera.rs
+++ b/src/view/camera.rs
@@ -1,57 +1,22 @@
-use bevy::prelude::Vec3;
+use bevy::prelude::*;
 
 use smooth_bevy_cameras::{LookAngles, LookTransform, LookTransformBundle, Smoother};
 
 use bevy::{
-    app::prelude::*,
-    ecs::{bundle::Bundle, prelude::*},
+    ecs::bundle::Bundle,
     input::{
         mouse::{MouseMotion, MouseScrollUnit, MouseWheel},
-        prelude::*,
     },
-    math::prelude::*,
     time::Time,
     transform::components::Transform,
 };
 
-pub struct OrbitCamera {
-    orbit: Vec3,
-
-}
-
-impl Default for OrbitCamera {
-
-    fn default() -> Self {
-        Self {
-            orbit: Default::default()
-        }
-    }
-
-}
-
-impl OrbitCamera {
-
-
-    pub fn new(orbit: Vec3) -> Self {
-        Self {
-            orbit
-        }
-    }
-
-    pub fn move_orbit(&mut self, x: f32, y: f32, z:f32) {
-        self.orbit.x += x;
-        self.orbit.y += y;
-        self.orbit.z += z;
-    }
-
-}
-
 #[derive(Default)]
-pub struct OrbitCameraPlugin {
+pub struct CameraPlugin {
     pub override_input_system: bool,
 }
 
-impl OrbitCameraPlugin {
+impl CameraPlugin {
     pub fn new(override_input_system: bool) -> Self {
         Self {
             override_input_system,
@@ -59,12 +24,12 @@ impl OrbitCameraPlugin {
     }
 }
 
-impl Plugin for OrbitCameraPlugin {
+impl Plugin for CameraPlugin {
     fn build(&self, app: &mut App) {
         let app = app
             .add_system(control_system)
-            .add_event::<ControlEvent>();
-
+            .add_event::<CameraControlEvent>();
+        
         if !self.override_input_system {
             app.add_system(default_input_map);
         }
@@ -72,15 +37,15 @@ impl Plugin for OrbitCameraPlugin {
 }
 
 #[derive(Bundle)]
-pub struct OrbitCameraBundle {
-    controller: OrbitCameraController,
+pub struct CameraBundle {
+    controller: CameraController,
     #[bundle]
     look_transform: LookTransformBundle,
     transform: Transform,
 }
 
-impl OrbitCameraBundle {
-    pub fn new(controller: OrbitCameraController, eye: Vec3, target: Vec3, up: Vec3) -> Self {
+impl CameraBundle {
+    pub fn new(controller: CameraController, eye: Vec3, target: Vec3, up: Vec3) -> Self {
         // Make sure the transform is consistent with the controller to start.
         let transform = Transform::from_translation(eye).looking_at(target, up);
 
@@ -98,7 +63,7 @@ impl OrbitCameraBundle {
 /// A 3rd person camera that orbits around the target.
 #[derive(Clone, Component, Copy, Debug)]
 #[cfg_attr(feature = "serde", derive(serde::Deserialize, serde::Serialize))]
-pub struct OrbitCameraController {
+pub struct CameraController {
     pub enabled: bool,
     pub mouse_rotate_sensitivity: Vec2,
     pub mouse_translate_sensitivity: Vec2,
@@ -107,32 +72,31 @@ pub struct OrbitCameraController {
     pub smoothing_weight: f32,
 }
 
-impl Default for OrbitCameraController {
+impl Default for CameraController {
     fn default() -> Self {
         Self {
             mouse_rotate_sensitivity: Vec2::splat(0.28),
-            mouse_translate_sensitivity: Vec2::splat(0.1),
+            mouse_translate_sensitivity: Vec2::splat(0.25),
             mouse_wheel_zoom_sensitivity: 0.2,
-            smoothing_weight: 0.8,
+            smoothing_weight: 0.4,
             enabled: true,
             pixels_per_line: 53.0,
         }
     }
 }
 
-pub enum ControlEvent {
+pub enum CameraControlEvent {
     Orbit(Vec2),
     TranslateTarget(Vec2),
     Zoom(f32),
 }
 
 pub fn default_input_map(
-    mut events: EventWriter<ControlEvent>,
+    mut events: EventWriter<CameraControlEvent>,
     mut mouse_wheel_reader: EventReader<MouseWheel>,
     mut mouse_motion_events: EventReader<MouseMotion>,
     mouse_buttons: Res<Input<MouseButton>>,
-    keyboard: Res<Input<KeyCode>>,
-    controllers: Query<&OrbitCameraController>,
+    controllers: Query<&CameraController>,
 ) {
     // Can only control one camera at a time.
     let controller = if let Some(controller) = controllers.iter().find(|c| c.enabled) {
@@ -140,7 +104,7 @@ pub fn default_input_map(
     } else {
         return;
     };
-    let OrbitCameraController {
+    let CameraController {
         mouse_rotate_sensitivity,
         mouse_translate_sensitivity,
         mouse_wheel_zoom_sensitivity,
@@ -154,11 +118,11 @@ pub fn default_input_map(
     }
 
     if mouse_buttons.pressed(MouseButton::Left) {
-        events.send(ControlEvent::Orbit(mouse_rotate_sensitivity * cursor_delta));
+        events.send(CameraControlEvent::Orbit(mouse_rotate_sensitivity * cursor_delta));
     }
 
-    if mouse_buttons.pressed(MouseButton::Right) {
-        events.send(ControlEvent::TranslateTarget(
+    if mouse_buttons.pressed(MouseButton::Middle) {
+        events.send(CameraControlEvent::TranslateTarget(
             mouse_translate_sensitivity * cursor_delta,
         ));
     }
@@ -172,13 +136,14 @@ pub fn default_input_map(
         };
         scalar *= 1.0 - scroll_amount * mouse_wheel_zoom_sensitivity;
     }
-    events.send(ControlEvent::Zoom(scalar));
+
+    events.send(CameraControlEvent::Zoom(scalar));
 }
 
 pub fn control_system(
     time: Res<Time>,
-    mut events: EventReader<ControlEvent>,
-    mut cameras: Query<(&OrbitCameraController, &mut LookTransform, &Transform)>,
+    mut events: EventReader<CameraControlEvent>,
+    mut cameras: Query<(&CameraController, &mut LookTransform, &Transform)>,
 ) {
     // Can only control one camera at a time.
     let (mut transform, scene_transform) =
@@ -194,16 +159,16 @@ pub fn control_system(
     let dt = time.delta_seconds();
     for event in events.iter() {
         match event {
-            ControlEvent::Orbit(delta) => {
+            CameraControlEvent::Orbit(delta) => {
                 look_angles.add_yaw(dt * -delta.x);
                 look_angles.add_pitch(dt * delta.y);
             }
-            ControlEvent::TranslateTarget(delta) => {
+            CameraControlEvent::TranslateTarget(delta) => {
                 let right_dir = scene_transform.rotation * -Vec3::X;
                 let up_dir = scene_transform.rotation * Vec3::Y;
                 transform.target += dt * delta.x * right_dir + dt * delta.y * up_dir;
             }
-            ControlEvent::Zoom(scalar) => {
+            CameraControlEvent::Zoom(scalar) => {
                 radius_scalar *= scalar;
             }
         }

